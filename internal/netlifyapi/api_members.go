/*
Netlify's API documentation

Netlify is a hosting service for the programmable web. It understands your documents and provides an API to handle atomic deploys of websites, manage form submissions, inject JavaScript snippets, and much more. This is a REST-style API that uses JSON for serialization and OAuth 2 for authentication.   This document is an OpenAPI reference for the Netlify API that you can explore. For more detailed instructions for common uses, please visit the [online documentation](https://docs.netlify.com/api/get-started/). Visit our Community forum to join the conversation about [understanding and using Netlifyâ€™s API](https://community.netlify.com/t/common-issue-understanding-and-using-netlifys-api/160).   Additionally, we have two API clients for your convenience: - [Go Client](https://github.com/netlify/open-api#go-client) - [JS Client](https://github.com/netlify/js-client) 

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netlifyapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// MembersAPIService MembersAPI service
type MembersAPIService service

type ApiAddMemberToAccountRequest struct {
	ctx context.Context
	ApiService *MembersAPIService
	accountId string
	email *string
	buildId *string
	role *string
}

// Email to invite to the account
func (r ApiAddMemberToAccountRequest) Email(email string) ApiAddMemberToAccountRequest {
	r.email = &email
	return r
}

// Build ID member was invited from
func (r ApiAddMemberToAccountRequest) BuildId(buildId string) ApiAddMemberToAccountRequest {
	r.buildId = &buildId
	return r
}

// Role of the new member
func (r ApiAddMemberToAccountRequest) Role(role string) ApiAddMemberToAccountRequest {
	r.role = &role
	return r
}

func (r ApiAddMemberToAccountRequest) Execute() (*Member, *http.Response, error) {
	return r.ApiService.AddMemberToAccountExecute(r)
}

/*
AddMemberToAccount Method for AddMemberToAccount

Creates a new member for the account (team).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Account ID or slug
 @return ApiAddMemberToAccountRequest
*/
func (a *MembersAPIService) AddMemberToAccount(ctx context.Context, accountId string) ApiAddMemberToAccountRequest {
	return ApiAddMemberToAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return Member
func (a *MembersAPIService) AddMemberToAccountExecute(r ApiAddMemberToAccountRequest) (*Member, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Member
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembersAPIService.AddMemberToAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{account_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}

	if r.buildId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "build_id", r.buildId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	if r.role != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role", r.role, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListMembersForAccountRequest struct {
	ctx context.Context
	ApiService *MembersAPIService
	accountId string
	emails *[]string
	page *string
	perPage *string
	roles *[]string
	siteId *string
	sortBy *string
	states *[]string
}

// Search for members in email field
func (r ApiListMembersForAccountRequest) Emails(emails []string) ApiListMembersForAccountRequest {
	r.emails = &emails
	return r
}

// Number of per_page to skip when returning records
func (r ApiListMembersForAccountRequest) Page(page string) ApiListMembersForAccountRequest {
	r.page = &page
	return r
}

// Number of records to return
func (r ApiListMembersForAccountRequest) PerPage(perPage string) ApiListMembersForAccountRequest {
	r.perPage = &perPage
	return r
}

// Filter members by role(s)
func (r ApiListMembersForAccountRequest) Roles(roles []string) ApiListMembersForAccountRequest {
	r.roles = &roles
	return r
}

// Filter members by a site
func (r ApiListMembersForAccountRequest) SiteId(siteId string) ApiListMembersForAccountRequest {
	r.siteId = &siteId
	return r
}

// Field of member to sort by (descending). When reviewer role is specified self_invite_pending and invite_pending are the defaults.
func (r ApiListMembersForAccountRequest) SortBy(sortBy string) ApiListMembersForAccountRequest {
	r.sortBy = &sortBy
	return r
}

// Filter members by invite state(s)
func (r ApiListMembersForAccountRequest) States(states []string) ApiListMembersForAccountRequest {
	r.states = &states
	return r
}

func (r ApiListMembersForAccountRequest) Execute() ([]Member, *http.Response, error) {
	return r.ApiService.ListMembersForAccountExecute(r)
}

/*
ListMembersForAccount Method for ListMembersForAccount

Returns a list of members for the account (team).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param accountId Account ID or slug
 @return ApiListMembersForAccountRequest
*/
func (a *MembersAPIService) ListMembersForAccount(ctx context.Context, accountId string) ApiListMembersForAccountRequest {
	return ApiListMembersForAccountRequest{
		ApiService: a,
		ctx: ctx,
		accountId: accountId,
	}
}

// Execute executes the request
//  @return []Member
func (a *MembersAPIService) ListMembersForAccountExecute(r ApiListMembersForAccountRequest) ([]Member, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Member
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MembersAPIService.ListMembersForAccount")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/{account_id}/members"
	localVarPath = strings.Replace(localVarPath, "{"+"account_id"+"}", url.PathEscape(parameterValueToString(r.accountId, "accountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.emails != nil {
		t := *r.emails
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "emails", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "emails", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.roles != nil {
		t := *r.roles
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "roles", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "roles", t, "multi")
		}
	}
	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", r.siteId, "")
	}
	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort_by", r.sortBy, "")
	}
	if r.states != nil {
		t := *r.states
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "states", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "states", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
