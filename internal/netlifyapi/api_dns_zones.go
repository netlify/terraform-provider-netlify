/*
Netlify's API documentation

Netlify is a hosting service for the programmable web. It understands your documents and provides an API to handle atomic deploys of websites, manage form submissions, inject JavaScript snippets, and much more. This is a REST-style API that uses JSON for serialization and OAuth 2 for authentication.   This document is an OpenAPI reference for the Netlify API that you can explore. For more detailed instructions for common uses, please visit the [online documentation](https://docs.netlify.com/api/get-started/). Visit our Community forum to join the conversation about [understanding and using Netlifyâ€™s API](https://community.netlify.com/t/common-issue-understanding-and-using-netlifys-api/160).   Additionally, we have two API clients for your convenience: - [Go Client](https://github.com/netlify/open-api#go-client) - [JS Client](https://github.com/netlify/js-client) 

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netlifyapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DNSZonesAPIService DNSZonesAPI service
type DNSZonesAPIService service

type ApiConfigureDNSForSiteRequest struct {
	ctx context.Context
	ApiService *DNSZonesAPIService
	siteId string
}

func (r ApiConfigureDNSForSiteRequest) Execute() ([]DnsZone, *http.Response, error) {
	return r.ApiService.ConfigureDNSForSiteExecute(r)
}

/*
ConfigureDNSForSite Method for ConfigureDNSForSite

Configures all automatic DNS entries for a site. Based on the custom
domain and domain aliases, create DNS zones and/or records if they
don't exist already.
This configuration usually runs automatically when the custom domain or
domain aliases are modified.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId The site ID
 @return ApiConfigureDNSForSiteRequest
*/
func (a *DNSZonesAPIService) ConfigureDNSForSite(ctx context.Context, siteId string) ApiConfigureDNSForSiteRequest {
	return ApiConfigureDNSForSiteRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return []DnsZone
func (a *DNSZonesAPIService) ConfigureDNSForSiteExecute(r ApiConfigureDNSForSiteRequest) ([]DnsZone, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DnsZone
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DNSZonesAPIService.ConfigureDNSForSite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/dns"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDnsRecordRequest struct {
	ctx context.Context
	ApiService *DNSZonesAPIService
	zoneId string
	dnsRecordCreateParams *DnsRecordCreateParams
}

// 
func (r ApiCreateDnsRecordRequest) DnsRecordCreateParams(dnsRecordCreateParams DnsRecordCreateParams) ApiCreateDnsRecordRequest {
	r.dnsRecordCreateParams = &dnsRecordCreateParams
	return r
}

func (r ApiCreateDnsRecordRequest) Execute() (*DnsRecord, *http.Response, error) {
	return r.ApiService.CreateDnsRecordExecute(r)
}

/*
CreateDnsRecord Method for CreateDnsRecord

Creates a DNS record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param zoneId The ID or the name of the DNS zone
 @return ApiCreateDnsRecordRequest
*/
func (a *DNSZonesAPIService) CreateDnsRecord(ctx context.Context, zoneId string) ApiCreateDnsRecordRequest {
	return ApiCreateDnsRecordRequest{
		ApiService: a,
		ctx: ctx,
		zoneId: zoneId,
	}
}

// Execute executes the request
//  @return DnsRecord
func (a *DNSZonesAPIService) CreateDnsRecordExecute(r ApiCreateDnsRecordRequest) (*DnsRecord, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DnsRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DNSZonesAPIService.CreateDnsRecord")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/dns_zones/{zone_id}/dns_records"
	localVarPath = strings.Replace(localVarPath, "{"+"zone_id"+"}", url.PathEscape(parameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dnsRecordCreateParams == nil {
		return localVarReturnValue, nil, reportError("dnsRecordCreateParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsRecordCreateParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateDnsZoneRequest struct {
	ctx context.Context
	ApiService *DNSZonesAPIService
	dnsZoneCreateParams *DnsZoneCreateParams
}

// 
func (r ApiCreateDnsZoneRequest) DnsZoneCreateParams(dnsZoneCreateParams DnsZoneCreateParams) ApiCreateDnsZoneRequest {
	r.dnsZoneCreateParams = &dnsZoneCreateParams
	return r
}

func (r ApiCreateDnsZoneRequest) Execute() (*DnsZone, *http.Response, error) {
	return r.ApiService.CreateDnsZoneExecute(r)
}

/*
CreateDnsZone Method for CreateDnsZone

Creates a DNS zone.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateDnsZoneRequest
*/
func (a *DNSZonesAPIService) CreateDnsZone(ctx context.Context) ApiCreateDnsZoneRequest {
	return ApiCreateDnsZoneRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DnsZone
func (a *DNSZonesAPIService) CreateDnsZoneExecute(r ApiCreateDnsZoneRequest) (*DnsZone, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DnsZone
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DNSZonesAPIService.CreateDnsZone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/dns_zones"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dnsZoneCreateParams == nil {
		return localVarReturnValue, nil, reportError("dnsZoneCreateParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsZoneCreateParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDnsRecordRequest struct {
	ctx context.Context
	ApiService *DNSZonesAPIService
	dnsRecordId string
	zoneId string
}

func (r ApiDeleteDnsRecordRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDnsRecordExecute(r)
}

/*
DeleteDnsRecord Method for DeleteDnsRecord

Deletes a DNS record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dnsRecordId The ID of the DNS record
 @param zoneId The ID or the name of the DNS zone
 @return ApiDeleteDnsRecordRequest
*/
func (a *DNSZonesAPIService) DeleteDnsRecord(ctx context.Context, dnsRecordId string, zoneId string) ApiDeleteDnsRecordRequest {
	return ApiDeleteDnsRecordRequest{
		ApiService: a,
		ctx: ctx,
		dnsRecordId: dnsRecordId,
		zoneId: zoneId,
	}
}

// Execute executes the request
func (a *DNSZonesAPIService) DeleteDnsRecordExecute(r ApiDeleteDnsRecordRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DNSZonesAPIService.DeleteDnsRecord")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/dns_zones/{zone_id}/dns_records/{dns_record_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"dns_record_id"+"}", url.PathEscape(parameterValueToString(r.dnsRecordId, "dnsRecordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zone_id"+"}", url.PathEscape(parameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteDnsZoneRequest struct {
	ctx context.Context
	ApiService *DNSZonesAPIService
	zoneId string
}

func (r ApiDeleteDnsZoneRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteDnsZoneExecute(r)
}

/*
DeleteDnsZone Method for DeleteDnsZone

Deletes a DNS zone.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param zoneId The ID or the name of the DNS zone
 @return ApiDeleteDnsZoneRequest
*/
func (a *DNSZonesAPIService) DeleteDnsZone(ctx context.Context, zoneId string) ApiDeleteDnsZoneRequest {
	return ApiDeleteDnsZoneRequest{
		ApiService: a,
		ctx: ctx,
		zoneId: zoneId,
	}
}

// Execute executes the request
func (a *DNSZonesAPIService) DeleteDnsZoneExecute(r ApiDeleteDnsZoneRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DNSZonesAPIService.DeleteDnsZone")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/dns_zones/{zone_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"zone_id"+"}", url.PathEscape(parameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnableDnsZoneIpv6Request struct {
	ctx context.Context
	ApiService *DNSZonesAPIService
	zoneId string
}

func (r ApiEnableDnsZoneIpv6Request) Execute() (*DnsZone, *http.Response, error) {
	return r.ApiService.EnableDnsZoneIpv6Execute(r)
}

/*
EnableDnsZoneIpv6 Method for EnableDnsZoneIpv6

Enables IPv6 with a DNS zone.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param zoneId The ID or the name of the DNS zone
 @return ApiEnableDnsZoneIpv6Request
*/
func (a *DNSZonesAPIService) EnableDnsZoneIpv6(ctx context.Context, zoneId string) ApiEnableDnsZoneIpv6Request {
	return ApiEnableDnsZoneIpv6Request{
		ApiService: a,
		ctx: ctx,
		zoneId: zoneId,
	}
}

// Execute executes the request
//  @return DnsZone
func (a *DNSZonesAPIService) EnableDnsZoneIpv6Execute(r ApiEnableDnsZoneIpv6Request) (*DnsZone, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DnsZone
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DNSZonesAPIService.EnableDnsZoneIpv6")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/dns_zones/{zone_id}/enable-ipv6"
	localVarPath = strings.Replace(localVarPath, "{"+"zone_id"+"}", url.PathEscape(parameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDNSForSiteRequest struct {
	ctx context.Context
	ApiService *DNSZonesAPIService
	siteId string
}

func (r ApiGetDNSForSiteRequest) Execute() ([]DnsZone, *http.Response, error) {
	return r.ApiService.GetDNSForSiteExecute(r)
}

/*
GetDNSForSite Method for GetDNSForSite

Returns a list of the DNS configuration for a site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId The site ID
 @return ApiGetDNSForSiteRequest
*/
func (a *DNSZonesAPIService) GetDNSForSite(ctx context.Context, siteId string) ApiGetDNSForSiteRequest {
	return ApiGetDNSForSiteRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return []DnsZone
func (a *DNSZonesAPIService) GetDNSForSiteExecute(r ApiGetDNSForSiteRequest) ([]DnsZone, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DnsZone
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DNSZonesAPIService.GetDNSForSite")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/dns"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDnsRecordsRequest struct {
	ctx context.Context
	ApiService *DNSZonesAPIService
	zoneId string
}

func (r ApiGetDnsRecordsRequest) Execute() ([]DnsRecord, *http.Response, error) {
	return r.ApiService.GetDnsRecordsExecute(r)
}

/*
GetDnsRecords Method for GetDnsRecords

Returns a list of DNS records.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param zoneId The ID or the name of the DNS zone
 @return ApiGetDnsRecordsRequest
*/
func (a *DNSZonesAPIService) GetDnsRecords(ctx context.Context, zoneId string) ApiGetDnsRecordsRequest {
	return ApiGetDnsRecordsRequest{
		ApiService: a,
		ctx: ctx,
		zoneId: zoneId,
	}
}

// Execute executes the request
//  @return []DnsRecord
func (a *DNSZonesAPIService) GetDnsRecordsExecute(r ApiGetDnsRecordsRequest) ([]DnsRecord, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DnsRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DNSZonesAPIService.GetDnsRecords")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/dns_zones/{zone_id}/dns_records"
	localVarPath = strings.Replace(localVarPath, "{"+"zone_id"+"}", url.PathEscape(parameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDnsZoneRequest struct {
	ctx context.Context
	ApiService *DNSZonesAPIService
	zoneId string
}

func (r ApiGetDnsZoneRequest) Execute() (*DnsZone, *http.Response, error) {
	return r.ApiService.GetDnsZoneExecute(r)
}

/*
GetDnsZone Method for GetDnsZone

Returns a DNS zone.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param zoneId The ID or the name of the DNS zone
 @return ApiGetDnsZoneRequest
*/
func (a *DNSZonesAPIService) GetDnsZone(ctx context.Context, zoneId string) ApiGetDnsZoneRequest {
	return ApiGetDnsZoneRequest{
		ApiService: a,
		ctx: ctx,
		zoneId: zoneId,
	}
}

// Execute executes the request
//  @return DnsZone
func (a *DNSZonesAPIService) GetDnsZoneExecute(r ApiGetDnsZoneRequest) (*DnsZone, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DnsZone
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DNSZonesAPIService.GetDnsZone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/dns_zones/{zone_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"zone_id"+"}", url.PathEscape(parameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDnsZonesRequest struct {
	ctx context.Context
	ApiService *DNSZonesAPIService
	accountSlug *string
	page *string
	perPage *string
}

// The account slug
func (r ApiGetDnsZonesRequest) AccountSlug(accountSlug string) ApiGetDnsZonesRequest {
	r.accountSlug = &accountSlug
	return r
}

// Number of per_page to skip when returning records
func (r ApiGetDnsZonesRequest) Page(page string) ApiGetDnsZonesRequest {
	r.page = &page
	return r
}

// Number of records to return
func (r ApiGetDnsZonesRequest) PerPage(perPage string) ApiGetDnsZonesRequest {
	r.perPage = &perPage
	return r
}

func (r ApiGetDnsZonesRequest) Execute() ([]DnsZone, *http.Response, error) {
	return r.ApiService.GetDnsZonesExecute(r)
}

/*
GetDnsZones Method for GetDnsZones

Returns a list of DNS zones. If the `account_slug` is passed, returns
the list for the account. Otherwise, returns the list for all DNS zones
that the current user has access to.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDnsZonesRequest
*/
func (a *DNSZonesAPIService) GetDnsZones(ctx context.Context) ApiGetDnsZonesRequest {
	return ApiGetDnsZonesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []DnsZone
func (a *DNSZonesAPIService) GetDnsZonesExecute(r ApiGetDnsZonesRequest) ([]DnsZone, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DnsZone
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DNSZonesAPIService.GetDnsZones")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/dns_zones"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.accountSlug != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "account_slug", r.accountSlug, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetIndividualDnsRecordRequest struct {
	ctx context.Context
	ApiService *DNSZonesAPIService
	dnsRecordId string
	zoneId string
}

func (r ApiGetIndividualDnsRecordRequest) Execute() (*DnsRecord, *http.Response, error) {
	return r.ApiService.GetIndividualDnsRecordExecute(r)
}

/*
GetIndividualDnsRecord Method for GetIndividualDnsRecord

Returns a DNS record.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dnsRecordId The ID of the DNS record
 @param zoneId The ID or the name of the DNS zone
 @return ApiGetIndividualDnsRecordRequest
*/
func (a *DNSZonesAPIService) GetIndividualDnsRecord(ctx context.Context, dnsRecordId string, zoneId string) ApiGetIndividualDnsRecordRequest {
	return ApiGetIndividualDnsRecordRequest{
		ApiService: a,
		ctx: ctx,
		dnsRecordId: dnsRecordId,
		zoneId: zoneId,
	}
}

// Execute executes the request
//  @return DnsRecord
func (a *DNSZonesAPIService) GetIndividualDnsRecordExecute(r ApiGetIndividualDnsRecordRequest) (*DnsRecord, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DnsRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DNSZonesAPIService.GetIndividualDnsRecord")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/dns_zones/{zone_id}/dns_records/{dns_record_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"dns_record_id"+"}", url.PathEscape(parameterValueToString(r.dnsRecordId, "dnsRecordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"zone_id"+"}", url.PathEscape(parameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTransferDnsZoneRequest struct {
	ctx context.Context
	ApiService *DNSZonesAPIService
	zoneId string
	dnsZoneTransferParams *DnsZoneTransferParams
}

// 
func (r ApiTransferDnsZoneRequest) DnsZoneTransferParams(dnsZoneTransferParams DnsZoneTransferParams) ApiTransferDnsZoneRequest {
	r.dnsZoneTransferParams = &dnsZoneTransferParams
	return r
}

func (r ApiTransferDnsZoneRequest) Execute() (*TransferDnsZone200Response, *http.Response, error) {
	return r.ApiService.TransferDnsZoneExecute(r)
}

/*
TransferDnsZone Method for TransferDnsZone

Transfers a DNS zone to the different account.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param zoneId The ID or the name of the DNS zone
 @return ApiTransferDnsZoneRequest
*/
func (a *DNSZonesAPIService) TransferDnsZone(ctx context.Context, zoneId string) ApiTransferDnsZoneRequest {
	return ApiTransferDnsZoneRequest{
		ApiService: a,
		ctx: ctx,
		zoneId: zoneId,
	}
}

// Execute executes the request
//  @return TransferDnsZone200Response
func (a *DNSZonesAPIService) TransferDnsZoneExecute(r ApiTransferDnsZoneRequest) (*TransferDnsZone200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransferDnsZone200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DNSZonesAPIService.TransferDnsZone")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/dns_zones/{zone_id}/transfer"
	localVarPath = strings.Replace(localVarPath, "{"+"zone_id"+"}", url.PathEscape(parameterValueToString(r.zoneId, "zoneId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dnsZoneTransferParams == nil {
		return localVarReturnValue, nil, reportError("dnsZoneTransferParams is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dnsZoneTransferParams
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
