/*
Netlify's API documentation

Netlify is a hosting service for the programmable web. It understands your documents and provides an API to handle atomic deploys of websites, manage form submissions, inject JavaScript snippets, and much more. This is a REST-style API that uses JSON for serialization and OAuth 2 for authentication.   This document is an OpenAPI reference for the Netlify API that you can explore. For more detailed instructions for common uses, please visit the [online documentation](https://docs.netlify.com/api/get-started/). Visit our Community forum to join the conversation about [understanding and using Netlifyâ€™s API](https://community.netlify.com/t/common-issue-understanding-and-using-netlifys-api/160).   Additionally, we have two API clients for your convenience: - [Go Client](https://github.com/netlify/open-api#go-client) - [JS Client](https://github.com/netlify/js-client) 

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netlifyapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// DeploysAPIService DeploysAPI service
type DeploysAPIService service

type ApiCancelSiteDeployRequest struct {
	ctx context.Context
	ApiService *DeploysAPIService
	deployId string
}

func (r ApiCancelSiteDeployRequest) Execute() (*Deploy, *http.Response, error) {
	return r.ApiService.CancelSiteDeployExecute(r)
}

/*
CancelSiteDeploy Method for CancelSiteDeploy

Cancels a deploy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deployId The ID of the deploy
 @return ApiCancelSiteDeployRequest
*/
func (a *DeploysAPIService) CancelSiteDeploy(ctx context.Context, deployId string) ApiCancelSiteDeployRequest {
	return ApiCancelSiteDeployRequest{
		ApiService: a,
		ctx: ctx,
		deployId: deployId,
	}
}

// Execute executes the request
//  @return Deploy
func (a *DeploysAPIService) CancelSiteDeployExecute(r ApiCancelSiteDeployRequest) (*Deploy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deploy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.CancelSiteDeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/deploys/{deploy_id}/cancel"
	localVarPath = strings.Replace(localVarPath, "{"+"deploy_id"+"}", url.PathEscape(parameterValueToString(r.deployId, "deployId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSiteDeployRequest struct {
	ctx context.Context
	ApiService *DeploysAPIService
	siteId string
	createSiteDeployRequest *CreateSiteDeployRequest
	title *string
}

// 
func (r ApiCreateSiteDeployRequest) CreateSiteDeployRequest(createSiteDeployRequest CreateSiteDeployRequest) ApiCreateSiteDeployRequest {
	r.createSiteDeployRequest = &createSiteDeployRequest
	return r
}

// The title of the deploy
func (r ApiCreateSiteDeployRequest) Title(title string) ApiCreateSiteDeployRequest {
	r.title = &title
	return r
}

func (r ApiCreateSiteDeployRequest) Execute() (*Deploy, *http.Response, error) {
	return r.ApiService.CreateSiteDeployExecute(r)
}

/*
CreateSiteDeploy Method for CreateSiteDeploy

Creates a deploy for a site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId The ID of the site
 @return ApiCreateSiteDeployRequest
*/
func (a *DeploysAPIService) CreateSiteDeploy(ctx context.Context, siteId string) ApiCreateSiteDeployRequest {
	return ApiCreateSiteDeployRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return Deploy
func (a *DeploysAPIService) CreateSiteDeployExecute(r ApiCreateSiteDeployRequest) (*Deploy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deploy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.CreateSiteDeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/deploys"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createSiteDeployRequest == nil {
		return localVarReturnValue, nil, reportError("createSiteDeployRequest is required and must be specified")
	}

	if r.title != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "title", r.title, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createSiteDeployRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteDeployRequest struct {
	ctx context.Context
	ApiService *DeploysAPIService
	deployId string
}

func (r ApiDeleteDeployRequest) Execute() (*Deploy, *http.Response, error) {
	return r.ApiService.DeleteDeployExecute(r)
}

/*
DeleteDeploy Method for DeleteDeploy

Marks a deploy for deletion.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deployId The ID of the deploy to delete
 @return ApiDeleteDeployRequest
*/
func (a *DeploysAPIService) DeleteDeploy(ctx context.Context, deployId string) ApiDeleteDeployRequest {
	return ApiDeleteDeployRequest{
		ApiService: a,
		ctx: ctx,
		deployId: deployId,
	}
}

// Execute executes the request
//  @return Deploy
func (a *DeploysAPIService) DeleteDeployExecute(r ApiDeleteDeployRequest) (*Deploy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deploy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.DeleteDeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/deploys/{deploy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"deploy_id"+"}", url.PathEscape(parameterValueToString(r.deployId, "deployId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSiteDeployRequest struct {
	ctx context.Context
	ApiService *DeploysAPIService
	deployId string
	siteId string
}

func (r ApiDeleteSiteDeployRequest) Execute() (*Deploy, *http.Response, error) {
	return r.ApiService.DeleteSiteDeployExecute(r)
}

/*
DeleteSiteDeploy Method for DeleteSiteDeploy

Marks a deploy for deletion.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deployId The ID of the deploy
 @param siteId The ID of the site
 @return ApiDeleteSiteDeployRequest
*/
func (a *DeploysAPIService) DeleteSiteDeploy(ctx context.Context, deployId string, siteId string) ApiDeleteSiteDeployRequest {
	return ApiDeleteSiteDeployRequest{
		ApiService: a,
		ctx: ctx,
		deployId: deployId,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return Deploy
func (a *DeploysAPIService) DeleteSiteDeployExecute(r ApiDeleteSiteDeployRequest) (*Deploy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deploy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.DeleteSiteDeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/deploys/{deploy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"deploy_id"+"}", url.PathEscape(parameterValueToString(r.deployId, "deployId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDeployRequest struct {
	ctx context.Context
	ApiService *DeploysAPIService
	deployId string
}

func (r ApiGetDeployRequest) Execute() (*Deploy, *http.Response, error) {
	return r.ApiService.GetDeployExecute(r)
}

/*
GetDeploy Method for GetDeploy

Returns details about a deploy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deployId The ID of the deploy
 @return ApiGetDeployRequest
*/
func (a *DeploysAPIService) GetDeploy(ctx context.Context, deployId string) ApiGetDeployRequest {
	return ApiGetDeployRequest{
		ApiService: a,
		ctx: ctx,
		deployId: deployId,
	}
}

// Execute executes the request
//  @return Deploy
func (a *DeploysAPIService) GetDeployExecute(r ApiGetDeployRequest) (*Deploy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deploy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.GetDeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/deploys/{deploy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"deploy_id"+"}", url.PathEscape(parameterValueToString(r.deployId, "deployId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSimplePublicDeployRequest struct {
	ctx context.Context
	ApiService *DeploysAPIService
	deployId string
}

func (r ApiGetSimplePublicDeployRequest) Execute() (*DeploySimple, *http.Response, error) {
	return r.ApiService.GetSimplePublicDeployExecute(r)
}

/*
GetSimplePublicDeploy Method for GetSimplePublicDeploy

Returns public information about a deploy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deployId The ID of the deploy
 @return ApiGetSimplePublicDeployRequest
*/
func (a *DeploysAPIService) GetSimplePublicDeploy(ctx context.Context, deployId string) ApiGetSimplePublicDeployRequest {
	return ApiGetSimplePublicDeployRequest{
		ApiService: a,
		ctx: ctx,
		deployId: deployId,
	}
}

// Execute executes the request
//  @return DeploySimple
func (a *DeploysAPIService) GetSimplePublicDeployExecute(r ApiGetSimplePublicDeployRequest) (*DeploySimple, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DeploySimple
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.GetSimplePublicDeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/deploys/{deploy_id}/simple"
	localVarPath = strings.Replace(localVarPath, "{"+"deploy_id"+"}", url.PathEscape(parameterValueToString(r.deployId, "deployId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteDeployRequest struct {
	ctx context.Context
	ApiService *DeploysAPIService
	deployId string
	siteId string
}

func (r ApiGetSiteDeployRequest) Execute() (*Deploy, *http.Response, error) {
	return r.ApiService.GetSiteDeployExecute(r)
}

/*
GetSiteDeploy Method for GetSiteDeploy

Returns details about a deploy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deployId The ID of the deploy
 @param siteId The ID of the site
 @return ApiGetSiteDeployRequest
*/
func (a *DeploysAPIService) GetSiteDeploy(ctx context.Context, deployId string, siteId string) ApiGetSiteDeployRequest {
	return ApiGetSiteDeployRequest{
		ApiService: a,
		ctx: ctx,
		deployId: deployId,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return Deploy
func (a *DeploysAPIService) GetSiteDeployExecute(r ApiGetSiteDeployRequest) (*Deploy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deploy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.GetSiteDeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/deploys/{deploy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"deploy_id"+"}", url.PathEscape(parameterValueToString(r.deployId, "deployId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSiteDeploysRequest struct {
	ctx context.Context
	ApiService *DeploysAPIService
	siteId string
	branch *string
	deployPreviews *bool
	from *int64
	latestPublished *bool
	page *int64
	perPage *int64
	production *bool
	state *string
	to *int64
}

// If provided, the branch on which to filter the list of deploys.
func (r ApiListSiteDeploysRequest) Branch(branch string) ApiListSiteDeploysRequest {
	r.branch = &branch
	return r
}

// If provided, filters the list of deploys to just deploy previews.
func (r ApiListSiteDeploysRequest) DeployPreviews(deployPreviews bool) ApiListSiteDeploysRequest {
	r.deployPreviews = &deployPreviews
	return r
}

// A Unix timestamp to filter for deploys created since a certain time
func (r ApiListSiteDeploysRequest) From(from int64) ApiListSiteDeploysRequest {
	r.from = &from
	return r
}

// If provided, sorts the list of deploys by published_at date, with the most recent deploy first.
func (r ApiListSiteDeploysRequest) LatestPublished(latestPublished bool) ApiListSiteDeploysRequest {
	r.latestPublished = &latestPublished
	return r
}

// Page of results to retrieve. Default is 1.
func (r ApiListSiteDeploysRequest) Page(page int64) ApiListSiteDeploysRequest {
	r.page = &page
	return r
}

// Number of deploys to retrieve per page. The default and maximum value is 100.
func (r ApiListSiteDeploysRequest) PerPage(perPage int64) ApiListSiteDeploysRequest {
	r.perPage = &perPage
	return r
}

// If provided, filters the list of deploys to just production deploys.
func (r ApiListSiteDeploysRequest) Production(production bool) ApiListSiteDeploysRequest {
	r.production = &production
	return r
}

// If provided, the state on which to filter the list of deploys.
func (r ApiListSiteDeploysRequest) State(state string) ApiListSiteDeploysRequest {
	r.state = &state
	return r
}

// A Unix timestamp to filter for deploys created before a certain time
func (r ApiListSiteDeploysRequest) To(to int64) ApiListSiteDeploysRequest {
	r.to = &to
	return r
}

func (r ApiListSiteDeploysRequest) Execute() ([]Deploy, *http.Response, error) {
	return r.ApiService.ListSiteDeploysExecute(r)
}

/*
ListSiteDeploys Method for ListSiteDeploys

Lists the deploys of a site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId The ID of the site
 @return ApiListSiteDeploysRequest
*/
func (a *DeploysAPIService) ListSiteDeploys(ctx context.Context, siteId string) ApiListSiteDeploysRequest {
	return ApiListSiteDeploysRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return []Deploy
func (a *DeploysAPIService) ListSiteDeploysExecute(r ApiListSiteDeploysRequest) ([]Deploy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []Deploy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.ListSiteDeploys")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/deploys"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.branch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "branch", r.branch, "")
	}
	if r.deployPreviews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deploy-previews", r.deployPreviews, "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.latestPublished != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latest-published", r.latestPublished, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.perPage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "per_page", r.perPage, "")
	}
	if r.production != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "production", r.production, "")
	}
	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLockDeployRequest struct {
	ctx context.Context
	ApiService *DeploysAPIService
	deployId string
}

func (r ApiLockDeployRequest) Execute() (*Deploy, *http.Response, error) {
	return r.ApiService.LockDeployExecute(r)
}

/*
LockDeploy Method for LockDeploy

Locks a specific deploy (subsequent deploys will be built but not published).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deployId The ID of the deploy to lock
 @return ApiLockDeployRequest
*/
func (a *DeploysAPIService) LockDeploy(ctx context.Context, deployId string) ApiLockDeployRequest {
	return ApiLockDeployRequest{
		ApiService: a,
		ctx: ctx,
		deployId: deployId,
	}
}

// Execute executes the request
//  @return Deploy
func (a *DeploysAPIService) LockDeployExecute(r ApiLockDeployRequest) (*Deploy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deploy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.LockDeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/deploys/{deploy_id}/lock"
	localVarPath = strings.Replace(localVarPath, "{"+"deploy_id"+"}", url.PathEscape(parameterValueToString(r.deployId, "deployId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestoreSiteDeployRequest struct {
	ctx context.Context
	ApiService *DeploysAPIService
	deployId string
	siteId string
}

func (r ApiRestoreSiteDeployRequest) Execute() (*Deploy, *http.Response, error) {
	return r.ApiService.RestoreSiteDeployExecute(r)
}

/*
RestoreSiteDeploy Method for RestoreSiteDeploy

Deploys a different version of a site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deployId The ID of the deploy to restore the site to
 @param siteId The ID of the site
 @return ApiRestoreSiteDeployRequest
*/
func (a *DeploysAPIService) RestoreSiteDeploy(ctx context.Context, deployId string, siteId string) ApiRestoreSiteDeployRequest {
	return ApiRestoreSiteDeployRequest{
		ApiService: a,
		ctx: ctx,
		deployId: deployId,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return Deploy
func (a *DeploysAPIService) RestoreSiteDeployExecute(r ApiRestoreSiteDeployRequest) (*Deploy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deploy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.RestoreSiteDeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/deploys/{deploy_id}/restore"
	localVarPath = strings.Replace(localVarPath, "{"+"deploy_id"+"}", url.PathEscape(parameterValueToString(r.deployId, "deployId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUnlockDeployRequest struct {
	ctx context.Context
	ApiService *DeploysAPIService
	deployId string
}

func (r ApiUnlockDeployRequest) Execute() (*Deploy, *http.Response, error) {
	return r.ApiService.UnlockDeployExecute(r)
}

/*
UnlockDeploy Method for UnlockDeploy

Unlocks a specific deploy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deployId The ID of the deploy to unlock
 @return ApiUnlockDeployRequest
*/
func (a *DeploysAPIService) UnlockDeploy(ctx context.Context, deployId string) ApiUnlockDeployRequest {
	return ApiUnlockDeployRequest{
		ApiService: a,
		ctx: ctx,
		deployId: deployId,
	}
}

// Execute executes the request
//  @return Deploy
func (a *DeploysAPIService) UnlockDeployExecute(r ApiUnlockDeployRequest) (*Deploy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deploy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.UnlockDeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/deploys/{deploy_id}/unlock"
	localVarPath = strings.Replace(localVarPath, "{"+"deploy_id"+"}", url.PathEscape(parameterValueToString(r.deployId, "deployId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSiteDeployRequest struct {
	ctx context.Context
	ApiService *DeploysAPIService
	deployId string
	siteId string
	updateSiteDeployRequest *UpdateSiteDeployRequest
}

// , await_ready_signal: boolean]
func (r ApiUpdateSiteDeployRequest) UpdateSiteDeployRequest(updateSiteDeployRequest UpdateSiteDeployRequest) ApiUpdateSiteDeployRequest {
	r.updateSiteDeployRequest = &updateSiteDeployRequest
	return r
}

func (r ApiUpdateSiteDeployRequest) Execute() (*Deploy, *http.Response, error) {
	return r.ApiService.UpdateSiteDeployExecute(r)
}

/*
UpdateSiteDeploy Method for UpdateSiteDeploy

Updates a deploy for a site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deployId The ID of the deploy
 @param siteId The ID of the site
 @return ApiUpdateSiteDeployRequest
*/
func (a *DeploysAPIService) UpdateSiteDeploy(ctx context.Context, deployId string, siteId string) ApiUpdateSiteDeployRequest {
	return ApiUpdateSiteDeployRequest{
		ApiService: a,
		ctx: ctx,
		deployId: deployId,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return Deploy
func (a *DeploysAPIService) UpdateSiteDeployExecute(r ApiUpdateSiteDeployRequest) (*Deploy, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Deploy
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploysAPIService.UpdateSiteDeploy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/deploys/{deploy_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"deploy_id"+"}", url.PathEscape(parameterValueToString(r.deployId, "deployId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateSiteDeployRequest == nil {
		return localVarReturnValue, nil, reportError("updateSiteDeployRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateSiteDeployRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
