/*
Netlify's API documentation

Netlify is a hosting service for the programmable web. It understands your documents and provides an API to handle atomic deploys of websites, manage form submissions, inject JavaScript snippets, and much more. This is a REST-style API that uses JSON for serialization and OAuth 2 for authentication.   This document is an OpenAPI reference for the Netlify API that you can explore. For more detailed instructions for common uses, please visit the [online documentation](https://docs.netlify.com/api/get-started/). Visit our Community forum to join the conversation about [understanding and using Netlifyâ€™s API](https://community.netlify.com/t/common-issue-understanding-and-using-netlifys-api/160).   Additionally, we have two API clients for your convenience: - [Go Client](https://github.com/netlify/open-api#go-client) - [JS Client](https://github.com/netlify/js-client) 

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netlifyapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// HooksAPIService HooksAPI service
type HooksAPIService service

type ApiCreateHookBySiteIdRequest struct {
	ctx context.Context
	ApiService *HooksAPIService
	createOutgoingHook *CreateOutgoingHook
}

// 
func (r ApiCreateHookBySiteIdRequest) CreateOutgoingHook(createOutgoingHook CreateOutgoingHook) ApiCreateHookBySiteIdRequest {
	r.createOutgoingHook = &createOutgoingHook
	return r
}

func (r ApiCreateHookBySiteIdRequest) Execute() (*OutgoingHook, *http.Response, error) {
	return r.ApiService.CreateHookBySiteIdExecute(r)
}

/*
CreateHookBySiteId Method for CreateHookBySiteId

Creates a new outgoing hook.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateHookBySiteIdRequest
*/
func (a *HooksAPIService) CreateHookBySiteId(ctx context.Context) ApiCreateHookBySiteIdRequest {
	return ApiCreateHookBySiteIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OutgoingHook
func (a *HooksAPIService) CreateHookBySiteIdExecute(r ApiCreateHookBySiteIdRequest) (*OutgoingHook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OutgoingHook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HooksAPIService.CreateHookBySiteId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/hooks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOutgoingHook == nil {
		return localVarReturnValue, nil, reportError("createOutgoingHook is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOutgoingHook
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteHookRequest struct {
	ctx context.Context
	ApiService *HooksAPIService
	hookId string
}

func (r ApiDeleteHookRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteHookExecute(r)
}

/*
DeleteHook Method for DeleteHook

Deletes an outgoing hook.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hookId The hook ID
 @return ApiDeleteHookRequest
*/
func (a *HooksAPIService) DeleteHook(ctx context.Context, hookId string) ApiDeleteHookRequest {
	return ApiDeleteHookRequest{
		ApiService: a,
		ctx: ctx,
		hookId: hookId,
	}
}

// Execute executes the request
func (a *HooksAPIService) DeleteHookExecute(r ApiDeleteHookRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HooksAPIService.DeleteHook")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/hooks/{hook_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"hook_id"+"}", url.PathEscape(parameterValueToString(r.hookId, "hookId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnableHookRequest struct {
	ctx context.Context
	ApiService *HooksAPIService
	hookId string
}

func (r ApiEnableHookRequest) Execute() (*OutgoingHook, *http.Response, error) {
	return r.ApiService.EnableHookExecute(r)
}

/*
EnableHook Method for EnableHook

Enables an outgoing hook that was disabled due to the error count.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hookId The hook ID
 @return ApiEnableHookRequest
*/
func (a *HooksAPIService) EnableHook(ctx context.Context, hookId string) ApiEnableHookRequest {
	return ApiEnableHookRequest{
		ApiService: a,
		ctx: ctx,
		hookId: hookId,
	}
}

// Execute executes the request
//  @return OutgoingHook
func (a *HooksAPIService) EnableHookExecute(r ApiEnableHookRequest) (*OutgoingHook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OutgoingHook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HooksAPIService.EnableHook")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/hooks/{hook_id}/enable"
	localVarPath = strings.Replace(localVarPath, "{"+"hook_id"+"}", url.PathEscape(parameterValueToString(r.hookId, "hookId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHookRequest struct {
	ctx context.Context
	ApiService *HooksAPIService
	hookId string
}

func (r ApiGetHookRequest) Execute() (*OutgoingHook, *http.Response, error) {
	return r.ApiService.GetHookExecute(r)
}

/*
GetHook Method for GetHook

Returns an outgoing hook.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hookId The hook ID
 @return ApiGetHookRequest
*/
func (a *HooksAPIService) GetHook(ctx context.Context, hookId string) ApiGetHookRequest {
	return ApiGetHookRequest{
		ApiService: a,
		ctx: ctx,
		hookId: hookId,
	}
}

// Execute executes the request
//  @return OutgoingHook
func (a *HooksAPIService) GetHookExecute(r ApiGetHookRequest) (*OutgoingHook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OutgoingHook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HooksAPIService.GetHook")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/hooks/{hook_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"hook_id"+"}", url.PathEscape(parameterValueToString(r.hookId, "hookId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListHookTypesRequest struct {
	ctx context.Context
	ApiService *HooksAPIService
	siteId *string
}

// site_id
func (r ApiListHookTypesRequest) SiteId(siteId string) ApiListHookTypesRequest {
	r.siteId = &siteId
	return r
}

func (r ApiListHookTypesRequest) Execute() ([]OutgoingHookType, *http.Response, error) {
	return r.ApiService.ListHookTypesExecute(r)
}

/*
ListHookTypes Method for ListHookTypes

Returns a list of hook types that are available.

Returns only a list of available hook types to the site if the `site_id`.
is given.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListHookTypesRequest
*/
func (a *HooksAPIService) ListHookTypes(ctx context.Context) ApiListHookTypesRequest {
	return ApiListHookTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []OutgoingHookType
func (a *HooksAPIService) ListHookTypesExecute(r ApiListHookTypesRequest) ([]OutgoingHookType, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OutgoingHookType
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HooksAPIService.ListHookTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/hooks/types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", r.siteId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListHooksBySiteIdRequest struct {
	ctx context.Context
	ApiService *HooksAPIService
	siteId *string
	event *string
	formId *string
}

// site_id
func (r ApiListHooksBySiteIdRequest) SiteId(siteId string) ApiListHooksBySiteIdRequest {
	r.siteId = &siteId
	return r
}

// The name of the hook event
func (r ApiListHooksBySiteIdRequest) Event(event string) ApiListHooksBySiteIdRequest {
	r.event = &event
	return r
}

// form_id
func (r ApiListHooksBySiteIdRequest) FormId(formId string) ApiListHooksBySiteIdRequest {
	r.formId = &formId
	return r
}

func (r ApiListHooksBySiteIdRequest) Execute() ([]OutgoingHook, *http.Response, error) {
	return r.ApiService.ListHooksBySiteIdExecute(r)
}

/*
ListHooksBySiteId Method for ListHooksBySiteId

Returns a list of outgoing hooks of site. You can pass form_id or
event to filter the result.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListHooksBySiteIdRequest
*/
func (a *HooksAPIService) ListHooksBySiteId(ctx context.Context) ApiListHooksBySiteIdRequest {
	return ApiListHooksBySiteIdRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []OutgoingHook
func (a *HooksAPIService) ListHooksBySiteIdExecute(r ApiListHooksBySiteIdRequest) ([]OutgoingHook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []OutgoingHook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HooksAPIService.ListHooksBySiteId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/hooks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.siteId == nil {
		return localVarReturnValue, nil, reportError("siteId is required and must be specified")
	}

	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "")
	}
	if r.formId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "form_id", r.formId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", r.siteId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateHookRequest struct {
	ctx context.Context
	ApiService *HooksAPIService
	hookId string
	updateOutgoingHook *UpdateOutgoingHook
}

// 
func (r ApiUpdateHookRequest) UpdateOutgoingHook(updateOutgoingHook UpdateOutgoingHook) ApiUpdateHookRequest {
	r.updateOutgoingHook = &updateOutgoingHook
	return r
}

func (r ApiUpdateHookRequest) Execute() (*OutgoingHook, *http.Response, error) {
	return r.ApiService.UpdateHookExecute(r)
}

/*
UpdateHook Method for UpdateHook

Updates an outgoing hook.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hookId The hook ID
 @return ApiUpdateHookRequest
*/
func (a *HooksAPIService) UpdateHook(ctx context.Context, hookId string) ApiUpdateHookRequest {
	return ApiUpdateHookRequest{
		ApiService: a,
		ctx: ctx,
		hookId: hookId,
	}
}

// Execute executes the request
//  @return OutgoingHook
func (a *HooksAPIService) UpdateHookExecute(r ApiUpdateHookRequest) (*OutgoingHook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OutgoingHook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "HooksAPIService.UpdateHook")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/hooks/{hook_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"hook_id"+"}", url.PathEscape(parameterValueToString(r.hookId, "hookId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateOutgoingHook == nil {
		return localVarReturnValue, nil, reportError("updateOutgoingHook is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateOutgoingHook
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
