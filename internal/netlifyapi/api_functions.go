/*
Netlify's API documentation

Netlify is a hosting service for the programmable web. It understands your documents and provides an API to handle atomic deploys of websites, manage form submissions, inject JavaScript snippets, and much more. This is a REST-style API that uses JSON for serialization and OAuth 2 for authentication.   This document is an OpenAPI reference for the Netlify API that you can explore. For more detailed instructions for common uses, please visit the [online documentation](https://docs.netlify.com/api/get-started/). Visit our Community forum to join the conversation about [understanding and using Netlifyâ€™s API](https://community.netlify.com/t/common-issue-understanding-and-using-netlifys-api/160).   Additionally, we have two API clients for your convenience: - [Go Client](https://github.com/netlify/open-api#go-client) - [JS Client](https://github.com/netlify/js-client) 

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package netlifyapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// FunctionsAPIService FunctionsAPI service
type FunctionsAPIService service

type ApiUploadDeployFunctionRequest struct {
	ctx context.Context
	ApiService *FunctionsAPIService
	deployId string
	name string
	body *os.File
	runtime *string
}

// file
func (r ApiUploadDeployFunctionRequest) Body(body *os.File) ApiUploadDeployFunctionRequest {
	r.body = body
	return r
}

// The runtime of the function
func (r ApiUploadDeployFunctionRequest) Runtime(runtime string) ApiUploadDeployFunctionRequest {
	r.runtime = &runtime
	return r
}

func (r ApiUploadDeployFunctionRequest) Execute() (*UploadDeployFunction200Response, *http.Response, error) {
	return r.ApiService.UploadDeployFunctionExecute(r)
}

/*
UploadDeployFunction Method for UploadDeployFunction

Uploads a function of the deploy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param deployId The ID of the deploy
 @param name The name of the function
 @return ApiUploadDeployFunctionRequest
*/
func (a *FunctionsAPIService) UploadDeployFunction(ctx context.Context, deployId string, name string) ApiUploadDeployFunctionRequest {
	return ApiUploadDeployFunctionRequest{
		ApiService: a,
		ctx: ctx,
		deployId: deployId,
		name: name,
	}
}

// Execute executes the request
//  @return UploadDeployFunction200Response
func (a *FunctionsAPIService) UploadDeployFunctionExecute(r ApiUploadDeployFunctionRequest) (*UploadDeployFunction200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UploadDeployFunction200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "FunctionsAPIService.UploadDeployFunction")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/deploys/{deploy_id}/functions/{name}"
	localVarPath = strings.Replace(localVarPath, "{"+"deploy_id"+"}", url.PathEscape(parameterValueToString(r.deployId, "deployId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	if r.runtime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "runtime", r.runtime, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
